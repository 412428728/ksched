// Code generated by protoc-gen-gogo.
// source: task_final_report.proto
// DO NOT EDIT!

package firmament

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type TaskFinalReport struct {
	TaskId       uint64  `protobuf:"varint,1,opt,name=task_id,json=taskId,proto3" json:"task_id,omitempty"`
	StartTime    uint64  `protobuf:"varint,2,opt,name=start_time,json=startTime,proto3" json:"start_time,omitempty"`
	FinishTime   uint64  `protobuf:"varint,3,opt,name=finish_time,json=finishTime,proto3" json:"finish_time,omitempty"`
	Instructions uint64  `protobuf:"varint,4,opt,name=instructions,proto3" json:"instructions,omitempty"`
	Cycles       uint64  `protobuf:"varint,5,opt,name=cycles,proto3" json:"cycles,omitempty"`
	LlcRefs      uint64  `protobuf:"varint,6,opt,name=llc_refs,json=llcRefs,proto3" json:"llc_refs,omitempty"`
	LlcMisses    uint64  `protobuf:"varint,7,opt,name=llc_misses,json=llcMisses,proto3" json:"llc_misses,omitempty"`
	Runtime      float64 `protobuf:"fixed64,8,opt,name=runtime,proto3" json:"runtime,omitempty"`
}

func (m *TaskFinalReport) Reset()                    { *m = TaskFinalReport{} }
func (m *TaskFinalReport) String() string            { return proto.CompactTextString(m) }
func (*TaskFinalReport) ProtoMessage()               {}
func (*TaskFinalReport) Descriptor() ([]byte, []int) { return fileDescriptorTaskFinalReport, []int{0} }

func init() {
	proto.RegisterType((*TaskFinalReport)(nil), "firmament.TaskFinalReport")
}
func (m *TaskFinalReport) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *TaskFinalReport) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TaskId != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintTaskFinalReport(data, i, uint64(m.TaskId))
	}
	if m.StartTime != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintTaskFinalReport(data, i, uint64(m.StartTime))
	}
	if m.FinishTime != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintTaskFinalReport(data, i, uint64(m.FinishTime))
	}
	if m.Instructions != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintTaskFinalReport(data, i, uint64(m.Instructions))
	}
	if m.Cycles != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintTaskFinalReport(data, i, uint64(m.Cycles))
	}
	if m.LlcRefs != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintTaskFinalReport(data, i, uint64(m.LlcRefs))
	}
	if m.LlcMisses != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintTaskFinalReport(data, i, uint64(m.LlcMisses))
	}
	if m.Runtime != 0 {
		data[i] = 0x41
		i++
		i = encodeFixed64TaskFinalReport(data, i, uint64(math.Float64bits(float64(m.Runtime))))
	}
	return i, nil
}

func encodeFixed64TaskFinalReport(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32TaskFinalReport(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintTaskFinalReport(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *TaskFinalReport) Size() (n int) {
	var l int
	_ = l
	if m.TaskId != 0 {
		n += 1 + sovTaskFinalReport(uint64(m.TaskId))
	}
	if m.StartTime != 0 {
		n += 1 + sovTaskFinalReport(uint64(m.StartTime))
	}
	if m.FinishTime != 0 {
		n += 1 + sovTaskFinalReport(uint64(m.FinishTime))
	}
	if m.Instructions != 0 {
		n += 1 + sovTaskFinalReport(uint64(m.Instructions))
	}
	if m.Cycles != 0 {
		n += 1 + sovTaskFinalReport(uint64(m.Cycles))
	}
	if m.LlcRefs != 0 {
		n += 1 + sovTaskFinalReport(uint64(m.LlcRefs))
	}
	if m.LlcMisses != 0 {
		n += 1 + sovTaskFinalReport(uint64(m.LlcMisses))
	}
	if m.Runtime != 0 {
		n += 9
	}
	return n
}

func sovTaskFinalReport(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTaskFinalReport(x uint64) (n int) {
	return sovTaskFinalReport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TaskFinalReport) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTaskFinalReport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TaskFinalReport: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TaskFinalReport: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TaskId", wireType)
			}
			m.TaskId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TaskId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartTime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FinishTime", wireType)
			}
			m.FinishTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.FinishTime |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instructions", wireType)
			}
			m.Instructions = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Instructions |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cycles", wireType)
			}
			m.Cycles = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Cycles |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LlcRefs", wireType)
			}
			m.LlcRefs = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LlcRefs |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LlcMisses", wireType)
			}
			m.LlcMisses = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LlcMisses |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Runtime", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Runtime = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipTaskFinalReport(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTaskFinalReport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTaskFinalReport(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTaskFinalReport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTaskFinalReport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTaskFinalReport
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTaskFinalReport
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTaskFinalReport(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTaskFinalReport = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTaskFinalReport   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorTaskFinalReport = []byte{
	// 274 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x54, 0x90, 0xbf, 0x4e, 0xf3, 0x30,
	0x14, 0xc5, 0x3f, 0x7f, 0x94, 0xa4, 0xbd, 0x20, 0x81, 0x3c, 0x50, 0x83, 0x44, 0x41, 0x9d, 0x58,
	0x68, 0x07, 0xde, 0x80, 0x01, 0x89, 0x81, 0x25, 0xea, 0x1e, 0x25, 0x6e, 0x92, 0x5a, 0xc4, 0x76,
	0x65, 0xdf, 0x0c, 0xbc, 0x09, 0x8f, 0xc4, 0xc8, 0x23, 0x20, 0x78, 0x0b, 0x26, 0x6e, 0xae, 0xc5,
	0xc0, 0x70, 0xa5, 0xfc, 0xce, 0xb9, 0x7f, 0x4e, 0x0c, 0x73, 0xac, 0xe2, 0x73, 0xd9, 0x1a, 0x57,
	0xf5, 0x65, 0x68, 0xf6, 0x3e, 0xe0, 0x6a, 0x1f, 0x3c, 0x7a, 0x39, 0x6b, 0x4d, 0xb0, 0x95, 0x6d,
	0x1c, 0x5e, 0xdc, 0x76, 0x06, 0x77, 0x43, 0xbd, 0xd2, 0xde, 0xae, 0x3b, 0xdf, 0xf9, 0x35, 0x77,
	0xd4, 0x43, 0xcb, 0xc4, 0xc0, 0x5f, 0x69, 0x72, 0xf9, 0x2d, 0xe0, 0x64, 0x43, 0x5b, 0x1f, 0xc6,
	0xa5, 0x05, 0xef, 0x94, 0x73, 0xc8, 0xf9, 0x90, 0xd9, 0x2a, 0x71, 0x2d, 0x6e, 0x26, 0x45, 0x36,
	0xe2, 0xe3, 0x56, 0x5e, 0x02, 0x44, 0xac, 0x02, 0x96, 0x68, 0x6c, 0xa3, 0xfe, 0xb3, 0x37, 0x63,
	0x65, 0x43, 0x82, 0xbc, 0x82, 0x23, 0xca, 0x66, 0xe2, 0x2e, 0xf9, 0x07, 0xec, 0x43, 0x92, 0xb8,
	0x61, 0x09, 0xc7, 0xc6, 0x45, 0x0c, 0x83, 0x46, 0xe3, 0x5d, 0x54, 0x13, 0xee, 0xf8, 0xa3, 0xc9,
	0x33, 0xc8, 0xf4, 0x8b, 0xee, 0x9b, 0xa8, 0x0e, 0xd3, 0xed, 0x44, 0xf2, 0x1c, 0xa6, 0x7d, 0xaf,
	0xe9, 0xb7, 0xdb, 0xa8, 0x32, 0x76, 0x72, 0xe2, 0x82, 0x70, 0x8c, 0x35, 0x5a, 0xd6, 0xc4, 0x48,
	0x63, 0x79, 0x8a, 0x45, 0xca, 0x13, 0x0b, 0x52, 0x41, 0x1e, 0x06, 0xc7, 0x91, 0xa6, 0xe4, 0x89,
	0xe2, 0x17, 0xef, 0x4f, 0xdf, 0x3e, 0x17, 0xe2, 0x9d, 0xea, 0x83, 0xea, 0xf5, 0x6b, 0xf1, 0xaf,
	0xce, 0xf8, 0x55, 0xee, 0x7e, 0x02, 0x00, 0x00, 0xff, 0xff, 0xfa, 0x2b, 0x01, 0xad, 0x6a, 0x01,
	0x00, 0x00,
}
